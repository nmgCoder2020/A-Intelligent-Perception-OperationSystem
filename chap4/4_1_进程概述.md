#4.1 进程概述及状态设计与讨论

这一节我们将具体讨论进程的描述，对进程的状态做具体的讨论，但是这里不涉及具体的实现方式。

###进程状态描述

进程的几种状态描述：


![status](./image/status.png)

这里完全是从状态的角度分析了进程的状态描述，我们可以发现在进程的状态上，和传统的进程状态的区别并不是太大，因为计算机就是一个自动状态机，进程的状态几乎反映了计算机的状态，这是根据现代计算机体级结构和现代计算方法决定的。如果不是体系结构发生质的变化或者形式上的变化，我们很难改变其状态描述。

如图所示，我们也描述了Parallex进程状态。

####创建态：

      计算机就是为了帮助我们计算问题的，所以必须由进程的创建态，在Parallex中就是进程创建向
      进程管理器发送消息，请求资源这个过程其实就是创建态，此时创建发送所有进程对资源的需求消
      息。
      
      使用代码考虑有如下实例：
```
    pid_t create_process(){
            
            pid_t pid = sys_send(message);
            /*获取ID 的消息*/
            void * mem = sys_send(message);
            /*获取内存的消息*/
            schedule_t sche = sys_send(message);
            /*获取调度信息的消息*/  
            IO_t   io   = sys_send(message);
            /*获取IO的消息*/
            mutex  mut  = sys_send(message);
            /*锁的相关信息*/
            ......
            ......
    
    }
    我们首先通过消息的发送来体现一个进程的创建行为
``` 
####就绪态：

        就绪态描述的是一个进程已经具备了可以被调度运行的状它，在资源的层面上它已经完全准备
        好了，现在阶段只需要等待合适调度时机，当达到调度时机时，它的状态就会转移为运型态也就
        标志着它可以被运行了。
        
####运型态：
          
        运行态很简单就是可以上CPU运行的进程都属于运型态。是对进程与运行状态的描述于刻画。
        
####阻塞态
       
       当一个进程在运行过程中遇到阻塞事件的时候，它就进入阻塞态，进入这个状态的进程就必须放弃
       CPU，等待阻塞条件解除，当阻塞条件满足时，它就进入就绪态，从就绪态的角度来看就是资源
       满足后等待被调用运行它就是运行态的。
       
       阻塞条件的描述，当发生以下两情况的时候进程就会进入阻塞态：
       @IO处理的时候，IO操作往往非常耗时。
       @等待一个资源而不得的时候，例如网络程序等待数据交互。
       
       阻塞态，本质上是对于必须资源暂时无法获取的情况而衍生出来的处理状态。
       
####挂起态

       挂起态，挂起态其实是为了虚拟内存生的，如果说阻塞态是因为一个进程求取一个资源而不得的
       话，并且影响是暂时的。挂起态也是因为这个原因，不同的两点是，被挂起的进程优先级更加低，
       并且它被换入了磁盘，进程的存储位置已经发生了根本的变化。可以说挂起态是阻塞态加具体化的
       表现形式。
       
####结束态
  
        如果说parallex在进程状态与别的操作系统或是传统进程状态转移模型有什么不一样的东西，
        那么第一个就是在进程状态上的改变，结束状态的加入，现代计算机CPU遭遇瓶颈，核心计算
        计算水平也就是常说的主频没有太大的进步，但是内存和显卡却还在不断发展，内存现在动辄
        可以达到十几G，专业服务器已经开始使用百G内存条，更加方便使用多道程序设计，可存储的进
        程实体更多，更大。所以当进程结束时我们没有必要立刻释放所有资源，可以让其多存在于内存
        一段时间，以防止在次调用，重新组织进程浪费时间，消息传递模型的最大问题在于通信和速度偏低，
        我们要解决的问题就是加快这个过程。结束态算是一种必须的状态吧。
        
####死亡态
 
        死亡态就是进程彻底死亡，所有资源完全回收的状态。进入这个状态的进程什么都不需要做，只
        要静静等待资源被回收就可以了。
        
以上是对所有进程状态的解释，下来我们说说具体状态转移的过程。

###状态转移过程


创建态---创建态

       在资源还没有创建完成的时候，进程会一直处于这样一个状态。
       
创建态---就绪态
       
       进程管理器确定进程运行所需资源齐备。
       
就绪态---就绪态

       等待调度时机成熟，具体来说就是等待满足调度算法调度最小条件。
      
就绪态---运行态

       满足调度条件，满足最小调度条件，上CPU运行。
       
运行态---结束态

       任务完成，状态转变为结束态，相当于缓存，可能会在次进入就绪态。
     
结束态---死亡态

       进程确定完全死亡，可以回收资源了，资源逐渐回收，这个过程已经没有挽回余地。
       
运行态---阻塞态
    
       进程遇到阻塞条件，进程进入阻塞状态，此时还存在于内存中。
       
阻塞态---阻塞态

       进程依然没有获取到阻塞解除条件。
       
阻塞态---就绪态

       进程已经获取解除阻塞条件，进程可以被再次调度。
       
运行态---挂起态

       这样多是因为内存需要使用交换空间，进程被整个放进了交换空间中，值的一提的时进程也很
       可能从就绪态直接进入挂起态，这样的情况是因为进程不重要但是没有明确杀死操作。
       
阻塞/挂起态---结束态

       阻塞和挂起是有条件限制，最简单的例如长时间的阻塞和挂起，我们就需要将他们放进结束态做
       进一步的考虑了。

###关于进程状态设计的几点讨论

####在设计进程状态的时候，我们如何确定状态的合理性？

我们之前说过在设计一个操作系统时，其中最为重要的就是进程的定义与描述，对于状态而言，其实本质上还是“两状态模型”，运行或未运行两种状态。从自动机理论来看，只要存在开始状态和接受状态就是最简状态了，其中的其它状态为中间状态，而这些状态本质是特点的具体化，是可以消除的，所以操作系统进程的状态数量和描述上没有限制。

####大多数操作系统设计的进程状态为什么都很类似？

首先，我们只考虑进程的状态描述，本质上都是两状态模型的衍生品，所以从根上来讲进程的状态本就不会有质的变化。

接着，我们考虑现代计算机就是一个有穷自动状态机，当然这是经典计算机，本质上是01，状态完全确定，虽然状太多但是有限。所以就是01限定了计算过程本身的状态，而最近比较火热的量子计算机，他是一种叠加态，每个时刻存在无数种状态，所以它的状态转移要更加复杂，和经典计算机有本质的区别，也许未来我们就能看到颠覆性的“进程”。

最后，学过“计算机组成原理”或者“微机原理”的应该了解，计算机采用的冯诺伊曼体系结构逻辑划分可以说是非常的合理，但是老天往往不遂人愿，硬件上差异太大，所以我们“两状态”模型之外的其它状态本质上是为了集合现在计算机体系结构而诞生的，如果说消除计算机各个部件的速度差异，那么计算机肯定就是两种状态，因为它可以变成一个整体，也许外观上来看计算机会变成一个“球体”或是“立方体”。

综上，在经典计算上运行的进程的状态将是围绕“两状态”模型的衍生，所以大都很相似。

